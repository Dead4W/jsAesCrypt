var aesCrypt;!function(){let e={version:"0.15",bufferSize:32768,fileFormatVersion:2,maxPassLen:1024,AESBlockSize:16},t={};const r={urandom:e=>crypto.getRandomValues(new Uint8Array(e)),arrToInt:e=>parseInt(Array.prototype.map.call(e,e=>("00"+e.toString(16)).slice(-2)).join(""),16),bytes2str:e=>CryptoJS.enc.Latin1.stringify(CryptoJS.enc.Uint8Arr.parse(e))};async function n(e,r){let n=CryptoJS.enc.Uint8Arr.decode(CryptoJS.enc.Utf16LE.parse(e)),a=new t.BinaryStream;a.appendBytes(r),a.appendBytes("\0".repeat(16)),a=a.finalize();for(let e=0;e<8192;e++){let e=new t.BinaryStream(a);e.appendBytes(n),a=await t.webCryptSubtle.webHashSHA256(e.finalize())}return a}t=aesCrypt={encrypt:async function(a,i){if(i.length>e.maxPassLen)throw"Password is too long.";const s=r.urandom(e.AESBlockSize),y=await n(i,s),o=r.urandom(e.AESBlockSize),p=r.urandom(32);let l=new t.BinaryStream;l.appendBytes(o),l.appendBytes(p),l=await t.webCryptSubtle.webEncryptAes(l.finalize(),y,s);const w=await t.webCryptSubtle.webHashHMAC(l,y);return await async function(r,n,a,i,s,y){let o=new t.BinaryStream;o.appendBytes("AES"),o.appendBytes(e.fileFormatVersion),o.appendBytes(0);const p="jsAesCrypt "+e.version;o.appendBytes(0),o.appendBytes(1+("CREATED_BY"+p).length),o.appendBytes("CREATED_BY"),o.appendBytes(0),o.appendBytes(p),o.appendBytes([0,128]),o.appendBytes("\0".repeat(128)),o.appendBytes([0,0]),o.appendBytes(n),o.appendBytes(a),o.appendBytes(s);let l=new t.FileBytesReader(r),w=l.getLength(),c=new t.BinaryStream(await l.readBytes(l.getLength())),u=String.fromCharCode(w%e.AESBlockSize),f=await t.webCryptSubtle.webEncryptAes(c.finalize(),i,y),d=await t.webCryptSubtle.webHashHMAC(f,i);return o.appendBytes(f),o.appendBytes(u),o.appendBytes(d),await o.finalize()}(a,s,l,p,w,o)},decrypt:async function(a,i){if(i.length>e.maxPassLen)throw"Password is too long.";let s=new t.FileBytesReader(a);await async function(t){if("AES"!==r.bytes2str(await t.readBytes(3))||t.getLength()<136)throw"File is corrupted or not an AES Crypt \n(or jsAesCrypt) file.";if(await t.readByte()!==e.fileFormatVersion)throw"jsAesCrypt is only compatible with version \n2 of the AES Crypt file format.";let n;await t.readByte();do{if((n=await t.readBytes(2)).length<2)throw"File is corrupted.";(n=+r.arrToInt(n))>0&&await t.readBytes(n)}while(n>0)}(s);let y=await async function(e,a){let i=await e.readBytes(16);if(16!==i.length)throw"File is corrupted.";let s=await n(a,i),y=await e.readBytes(48);if(48!==y.length)throw"File is corrupted.";let o=r.bytes2str(await e.readBytes(32));if(32!==o.length)throw"File is corrupted.";let p=await t.webCryptSubtle.webHashHMAC(y,s);if(o!==r.bytes2str(p))throw"Wrong password (or file is corrupted).";return await t.webCryptSubtle.webDecryptAes(y,s,i,0)}(s,i),o=y.slice(0,e.AESBlockSize),p=y.slice(e.AESBlockSize,e.AESBlockSize+32),l=new t.BinaryStream(await s.readBytes(s.getLength()-s.getCurrentPosition()-32-1)),w=r.arrToInt(await s.readBytes(1)),c=await t.webCryptSubtle.webHashHMAC(l.finalize(),p),u=r.bytes2str(await s.readBytes(32));if(32!==u.length)throw"File is corrupted.";if(u!==r.bytes2str(c))throw"Bad HMAC (file is corrupted).";try{return await t.webCryptSubtle.webDecryptAes(l.finalize(),p,o,w)}catch{let r=await t.webCryptSubtle.webDecryptAes(l.finalize(),p,o,0),n=e.AESBlockSize-w;return r.slice(0,r.length-n)}},utils:r,info:e},"undefined"!=typeof window&&(window.aesCrypt=t)}(),aesCrypt.FileBytesReader=function(e){let t=0,r=e.size,n=new FileReader,a=e;async function i(e){return await function(e){return new Promise((r,i)=>{let s=a.slice(t,t+=e);n.onload=(()=>{r(new Uint8Array(n.result))}),n.onerror=i,n.readAsArrayBuffer(s)})}(e)}return{readByte:async function(){return(await i(1))[0]},readBytes:i,getCurrentPosition:function(){return t},getLength:function(){return r}}},aesCrypt.BinaryStream=function(e=[]){let t=new Uint8Array(e);return{appendBytes:function(e){let r=[];if("number"==typeof e)r=e.toString(16).match(/.{1,2}/g).map(e=>parseInt(e,16));else if("string"==typeof e)for(let t=0;t<e.length;t++)r.push(e.charCodeAt(t));else r=e;r=new Uint8Array(r);let n=new Uint8Array(t.length+r.length);n.set(t),n.set(r,t.length),t=n},finalize:function(){return t},getLength:function(){return t.length}}},function(){let e=aesCrypt;aesCrypt.webCryptSubtle={createKey:async(e,t,r)=>await crypto.subtle.importKey("raw",e.buffer,t,!1,r),async webHashHMAC(e,t){let r=await this.createKey(t,{name:"HMAC",hash:{name:"SHA-256"}},["sign","verify"]);return new Uint8Array(await crypto.subtle.sign("HMAC",r,e))},async webEncryptAes(t,r,n,a=!0){let i=await this.createKey(r,"AES-CBC",["encrypt","decrypt"]),s=new Uint8Array(await crypto.subtle.encrypt({name:"AES-CBC",iv:n},i,t));return t.length%e.info.AESBlockSize==0&&!0===a&&(s=s.slice(0,s.length-e.info.AESBlockSize)),s},webHashSHA256:async e=>new Uint8Array(await crypto.subtle.digest("SHA-256",e.buffer)),async webDecryptAes(t,r,n,a=0){let i=await this.createKey(r,"AES-CBC",["encrypt","decrypt"]),s=new e.BinaryStream(t);if(0===a){let a=[];for(let r=0;r<e.info.AESBlockSize;r++)a.push(0^t[t.length-e.info.AESBlockSize+r]);s.appendBytes(await this.webEncryptAes(new Uint8Array(a),r,n,!1))}let y=new Uint8Array(await crypto.subtle.decrypt({name:"AES-CBC",iv:n},i,s.finalize()));return 0===a&&(y=y.slice(0,y.length-e.info.AESBlockSize)),y}}}();