var aesCrypt;!function(){let e={version:"0.15",bufferSize:32768,fileFormatVersion:2,maxPassLen:1024,AESBlockSize:16};const t={urandom:e=>crypto.getRandomValues(new Uint8Array(e)),arrToInt:e=>parseInt(Array.prototype.map.call(e,e=>("00"+e.toString(16)).slice(-2)).join(""),16),bytes2str:e=>CryptoJS.enc.Latin1.stringify(CryptoJS.enc.Uint8Arr.parse(e)),str2bytes:(e,t="Latin1")=>CryptoJS.enc.Uint8Arr.decode(CryptoJS.enc[t].parse(e))};async function r(e,t){let r=CryptoJS.enc.Uint8Arr.decode(CryptoJS.enc.Utf16LE.parse(e)),a=new n.BinaryStream;a.appendBytes(t),a.appendBytes("\0".repeat(16)),a=a.finalize();for(let e=0;e<8192;e++){let e=new n.BinaryStream(a);e.appendBytes(r),a=await n.webCryptSubtle.webHashSHA256(e.finalize())}return a}var n=aesCrypt={encrypt:async function(a,i){if(i.length>e.maxPassLen)throw"Password is too long.";const s=t.urandom(e.AESBlockSize),y=await r(i,s),o=t.urandom(e.AESBlockSize),p=t.urandom(32);let l=new n.BinaryStream;l.appendBytes(o),l.appendBytes(p),l=await n.webCryptSubtle.webEncryptAes(l.finalize(),y,s);const w=await n.webCryptSubtle.webHashHMAC(l,y);return await async function(t,r,a,i,s,y){let o=new n.BinaryStream;o.appendBytes("AES"),o.appendBytes(e.fileFormatVersion),o.appendBytes(0);const p="jsAesCrypt "+e.version;o.appendBytes(0),o.appendBytes(1+("CREATED_BY"+p).length),o.appendBytes("CREATED_BY"),o.appendBytes(0),o.appendBytes(p),o.appendBytes([0,128]),o.appendBytes("\0".repeat(128)),o.appendBytes([0,0]),o.appendBytes(r),o.appendBytes(a),o.appendBytes(s);let l=new n.FileBytesReader(t),w=l.getLength(),c=new n.BinaryStream(await l.readBytes(l.getLength())),f=String.fromCharCode(w%e.AESBlockSize),d=await n.webCryptSubtle.webEncryptAes(c.finalize(),i,y),u=await n.webCryptSubtle.webHashHMAC(d,i);return o.appendBytes(d),o.appendBytes(f),o.appendBytes(u),await o.finalize()}(a,s,l,p,w,o)},decrypt:async function(a,i){if(i.length>e.maxPassLen)throw"Password is too long.";let s=new n.FileBytesReader(a);if("AES"!==t.bytes2str(await s.readBytes(3))||s.getLength()<136)throw"File is corrupted or not an AES Crypt \n(or jsAesCrypt) file.";if(await s.readByte()!==e.fileFormatVersion)throw"jsAesCrypt is only compatible with version \n2 of the AES Crypt file format.";for(await s.readByte();;){let e=await s.readBytes(2);if(e.length<2)throw"File is corrupted.";if(0==(e=+t.arrToInt(e)))break;await s.readBytes(e)}let y=await s.readBytes(16);if(16!==y.length)throw"File is corrupted.";let o=await r(i,y),p=await s.readBytes(48);if(48!==p.length)throw"File is corrupted.";let l=t.bytes2str(await s.readBytes(32));if(32!==l.length)throw"File is corrupted.";let w=await n.webCryptSubtle.webHashHMAC(p,o);if(l!==t.bytes2str(w))throw"Wrong password (or file is corrupted).";let c,f=(p=await n.webCryptSubtle.webDecryptAes(p,o,y,0)).slice(0,e.AESBlockSize),d=p.slice(e.AESBlockSize,e.AESBlockSize+32),u=new n.BinaryStream,B=new n.BinaryStream(await s.readBytes(s.getLength()-s.getCurrentPosition()-32-1)),S=t.arrToInt(await s.readBytes(1)),A=await n.webCryptSubtle.webHashHMAC(B.finalize(),d);try{c=await n.webCryptSubtle.webDecryptAes(B.finalize(),d,f,S)}catch{c=await n.webCryptSubtle.webDecryptAes(B.finalize(),d,f,0);let t=e.AESBlockSize-S;c=c.slice(0,c.length-t)}u.appendBytes(c);let h=t.bytes2str(await s.readBytes(32));if(32!==h.length)throw"File is corrupted.";if(h!==t.bytes2str(A))throw"Bad HMAC (file is corrupted).";return u.finalize()},utils:t,info:e};"undefined"!=typeof window&&(window.aesCrypt=n)}(),aesCrypt.FileBytesReader=function(e){let t=0,r=e.size,n=new FileReader,a=e;async function i(e){return await function(e){return new Promise((r,i)=>{let s=a.slice(t,t+=e);n.onload=(()=>{r(new Uint8Array(n.result))}),n.onerror=i,n.readAsArrayBuffer(s)})}(e)}return{readByte:async function(){return(await i(1))[0]},readBytes:i,getCurrentPosition:function(){return t},getLength:function(){return r}}},aesCrypt.BinaryStream=function(e=[]){let t=new Uint8Array(e);return{appendBytes:function(e){let r;if("number"==typeof e){let t=e.toString(16);r=new Uint8Array(t.match(/.{1,2}/g).map(e=>parseInt(e,16)))}else if("string"==typeof e){r=new Uint8Array(e.length);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t)}else r=new Uint8Array(e);let n=new Uint8Array(t.length+r.length);n.set(t),n.set(r,t.length),t=n},finalize:function(){return t},get:function(e){return t[e]},getLength:function(){return t.length}}},function(){let e=aesCrypt;aesCrypt.webCryptSubtle={createKey:async(e,t,r)=>await crypto.subtle.importKey("raw",e.buffer,t,!1,r),async webHashHMAC(e,t){let r=await this.createKey(t,{name:"HMAC",hash:{name:"SHA-256"}},["sign","verify"]);return new Uint8Array(await crypto.subtle.sign("HMAC",r,e))},async webEncryptAes(t,r,n,a=!0){let i=await this.createKey(r,"AES-CBC",["encrypt","decrypt"]),s=new Uint8Array(await crypto.subtle.encrypt({name:"AES-CBC",iv:n},i,t));return t.length%e.info.AESBlockSize==0&&!0===a&&(s=s.slice(0,s.length-e.info.AESBlockSize)),s},webHashSHA256:async e=>new Uint8Array(await crypto.subtle.digest("SHA-256",e.buffer)),async webDecryptAes(t,r,n,a=0){let i=await this.createKey(r,"AES-CBC",["encrypt","decrypt"]),s=new e.BinaryStream(t);if(0===a){let a=[];for(let r=0;r<e.info.AESBlockSize;r++)a.push(0^t[t.length-e.info.AESBlockSize+r]);s.appendBytes(await this.webEncryptAes(new Uint8Array(a),r,n,!1))}let y=new Uint8Array(await crypto.subtle.decrypt({name:"AES-CBC",iv:n},i,s.finalize()));return 0===a&&(y=y.slice(0,y.length-e.info.AESBlockSize)),y}}}();