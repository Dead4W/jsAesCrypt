AesCrypt=function(){let e={version:"0.15",bufferSize:32768,fileFormatVersion:2,maxPassLen:1024,AESBlockSize:16};var t=function(e){let t=0,r=e.size,a=new FileReader,i=e;async function s(e){return await function(e){return new Promise((n,r)=>{let s=i.slice(t,t+=e);a.onload=(()=>{n(new Uint8Array(a.result))}),a.onerror=r,a.readAsArrayBuffer(s)})}(e)}return{readByte:async function(){return(await s(1))[0]},readBytes:s,readBytesAsInt:async function(e){let t=await s(e);return n.arrToInt(t)},readBytesAsString:async function(e){let t=await s(e);return n.bytes2str(t)},getCurrentPosition:function(){return t},getLength:function(){return r}}},n={urandom:function(e){return crypto.getRandomValues(new Uint8Array(e))},arrToInt:function(e){return parseInt(Array.prototype.map.call(e,e=>("00"+e.toString(16)).slice(-2)).join(""),16)},bytes2str:function(e){return CryptoJS.enc.Latin1.stringify(CryptoJS.enc.Uint8Arr.parse(e))},str2bytes:function(e,t="Latin1"){return CryptoJS.enc.Uint8Arr.decode(CryptoJS.enc[t].parse(e))}};let r=function(e=[]){let t=new Uint8Array(e);return{appendBytes:function(e){let n;if("number"==typeof e){let t=e.toString(16);n=new Uint8Array(t.match(/.{1,2}/g).map(e=>parseInt(e,16)))}else if("string"==typeof e){n=new Uint8Array(e.length);for(let t=0;t<e.length;t++)n[t]=e.charCodeAt(t)}else n=new Uint8Array(e);let r=new Uint8Array(t.length+n.length);r.set(t),r.set(n,t.length),t=r},finalize:function(){return t},get:function(e){return t[e]},getLength:function(){return t.length}}};async function a(e,t,n){return await crypto.subtle.importKey("raw",e.buffer,t,!1,n)}async function i(e,t){let n=await a(t,{name:"HMAC",hash:{name:"SHA-256"}},["sign","verify"]);return new Uint8Array(await crypto.subtle.sign("HMAC",n,e))}async function s(t,n,r,i=!0){let s=await a(n,"AES-CBC",["encrypt","decrypt"]),o=new Uint8Array(await crypto.subtle.encrypt({name:"AES-CBC",iv:r},s,t));return t.length%e.AESBlockSize==0&&1==i&&(o=o.slice(0,o.length-e.AESBlockSize)),o}async function o(e){return new Uint8Array(await crypto.subtle.digest("SHA-256",e.buffer))}async function l(t,n,i,o=0){let l=await a(n,"AES-CBC",["encrypt","decrypt"]),c=r(t);if(0==o){let r=new Uint8Array(e.AESBlockSize);for(let n=0;n<e.AESBlockSize;n++)r[n]=0^t[t.length-e.AESBlockSize+n];modBlockEncrypted=await s(r,n,i,!1),c.appendBytes(modBlockEncrypted)}let y=new Uint8Array(await crypto.subtle.decrypt({name:"AES-CBC",iv:i},l,c.finalize()));return 0==o&&(y=y.slice(0,y.length-e.AESBlockSize)),y}async function c(e,t){let a=r();a.appendBytes(t),a.appendBytes("\0".repeat(16));let i=a.finalize();for(let t=0;t<8192;t++){let t=r(i);t.appendBytes(n.str2bytes(e,"Utf16LE")),i=await o(t.finalize(0))}return i}return{encrypt:async function(a,o){if(o.length>e.maxPassLen)return console.warn("Password is too long."),!1;const l=n.urandom(e.AESBlockSize),y=await c(o,l),p=n.urandom(e.AESBlockSize),u=n.urandom(32);let f=r();f.appendBytes(p),f.appendBytes(u);const d=await s(f.finalize(),y,l),w=await i(d,y);return await async function(n,a,o,l,c,y){let p=r();p.appendBytes("AES"),p.appendBytes(e.fileFormatVersion),p.appendBytes(0);const u="jsAesCrypt "+e.version;p.appendBytes(0),p.appendBytes(1+("CREATED_BY"+u).length),p.appendBytes("CREATED_BY"),p.appendBytes(0),p.appendBytes(u),p.appendBytes([0,128]),p.appendBytes("\0".repeat(128)),p.appendBytes([0,0]),p.appendBytes(a),p.appendBytes(o),p.appendBytes(c);let f=new t(n),d=f.getLength(),w=r(await f.readBytes(f.getLength())),B=String.fromCharCode(d%e.AESBlockSize);return cText=await s(w.finalize(),l,y),hmac0=await i(cText,l),p.appendBytes(cText),p.appendBytes(B),p.appendBytes(hmac0),await p.finalize()}(a,l,d,u,w,p)},decrypt:async function(a,s){if(s.length>e.maxPassLen)return console.warn("Password is too long."),!1;let o=t(a);if("AES"!==await o.readBytesAsString(3)||o.getLength()<136)return console.warn("File is corrupted or not an AES Crypt \n(or jsAesCrypt) file."),!1;if(await o.readByte()!==e.fileFormatVersion)return console.warn("jsAesCrypt is only compatible with version \n2 of the AES Crypt file format."),!1;for(await o.readByte();;){let e=await o.readBytes(2);if(e.length<2)return console.warn("File is corrupted."),!1;if(0==(e=+n.arrToInt(e)))break;await o.readBytes(e)}let y=await o.readBytes(16);if(16!==y.length)return console.warn("File is corrupted."),!1;let p=await c(s,y),u=await o.readBytes(48);if(48!==u.length)return console.warn("File is corrupted."),!1;let f=await o.readBytesAsString(32);if(32!==f.length)return console.warn("File is corrupted."),!1;let d=await i(u,p);if(f!==n.bytes2str(d))return console.warn("Wrong password (or file is corrupted)."),!1;let w,B=await l(u,p,y,0),A=B.slice(0,e.AESBlockSize),g=B.slice(e.AESBlockSize,e.AESBlockSize+32),S=r(),h=r(await o.readBytes(o.getLength()-o.getCurrentPosition()-32-1)),m=await o.readBytesAsInt(1);hmac0Act=await i(h.finalize(),g);try{w=await l(h.finalize(),g,A,m)}catch{w=await l(h.finalize(),g,A,0);let t=e.AESBlockSize-m;w=w.slice(0,w.length-t)}S.appendBytes(w);let E=await o.readBytesAsString(32);return 32!==E.length?(console.warn("File is corrupted."),!1):E!==n.bytes2str(hmac0Act)?(console.warn("Bad HMAC (file is corrupted)."),!1):S.finalize()},utils:n,info:e}};