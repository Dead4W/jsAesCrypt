AesCrypt=function(){const e={version:"0.1",bufferSize:8388608,fileFormatVersion:2,maxPassLen:1024,AESBlockSize:16};function t(e,t){return CryptoJS.algo.AES.createEncryptor(Utilities.encode_to_words(e),{mode:CryptoJS.mode.CBC,iv:CryptoJS.enc.Latin1.parse(t),padding:CryptoJS.pad.NoPadding})}function n(e,t){return CryptoJS.algo.AES.createDecryptor(Utilities.encode_to_words(e),{mode:CryptoJS.mode.CBC,iv:CryptoJS.enc.Latin1.parse(t),padding:CryptoJS.pad.NoPadding})}function r(e,t){let n=Utilities.encode_to_words(t+"\0".repeat(16));for(let t=0;t<8192;t++){const t=CryptoJS.algo.SHA256.create();t.update(n),t.update(Utilities.encode_to_words(e,"Utf16LE")),n=t.finalize()}return n.toString(CryptoJS.enc.Latin1)}return Uint8Array.prototype.appendBytes=function(e){let t;if("number"==typeof e){const n=e.toString(16);t=new Uint8Array(n.match(/.{1,2}/g).map(e=>parseInt(e,16)))}else if("string"==typeof e){t=new Uint8Array(e.length);for(let n=0;n<e.length;n++)t[n]=e.charCodeAt(n)}else t=new Uint8Array(e);const n=new Uint8Array(this.length+t.length);return n.set(this),n.set(t,this.length),n},{encrypt:function(n,o){if(o.length>e.maxPassLen)return console.warn("Password is too long."),!1;const i=Utilities.urandom(e.AESBlockSize),s=r(o,i),a=Utilities.urandom(e.AESBlockSize),l=Utilities.urandom(32),c=t(l,a),p=CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256,Utilities.encode_to_words(l)),d=t(s,i),y=d.process(Utilities.encode_to_words(a+l)).toString(CryptoJS.enc.Latin1)+d.finalize().toString(CryptoJS.enc.Latin1),S=CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256,Utilities.encode_to_words(s));return S.update(Utilities.encode_to_words(y)),function(t,n,r,o,i,s){let a=new Uint8Array([]);a=(a=(a=a.appendBytes("AES")).appendBytes(e.fileFormatVersion)).appendBytes(0);const l="jsAesCrypt "+e.version;a=(a=(a=(a=(a=(a=(a=(a=(a=(a=(a=a.appendBytes(0)).appendBytes(1+("CREATED_BY"+l).length)).appendBytes("CREATED_BY")).appendBytes(0)).appendBytes(l)).appendBytes([0,128])).appendBytes(Utilities.fillArray(0,128))).appendBytes([0,0])).appendBytes(n)).appendBytes(r)).appendBytes(i.finalize().toString(CryptoJS.enc.Latin1));let c=String.fromCharCode(0);const p=Math.ceil(t.byteLength/e.bufferSize);for(let n=0;n<p;n++){let r=new Uint8Array(t.slice(n*e.bufferSize,(n+1)*e.bufferSize)),i=r.length,l=s.process(Utilities.encode_to_words(r,"Uint8Arr")).toString(CryptoJS.enc.Latin1);if(i<e.bufferSize){let t;c=String.fromCharCode(i%e.AESBlockSize),t=i%e.AESBlockSize==0?0:16-i%e.AESBlockSize;let n=c.repeat(t);l+=s.process(Utilities.encode_to_words(n)).toString(CryptoJS.enc.Latin1)}l+=s.finalize().toString(CryptoJS.enc.Latin1),o.update(Utilities.encode_to_words(l)),a=a.appendBytes(l)}return a=(a=a.appendBytes(c)).appendBytes(o.finalize().toString(CryptoJS.enc.Latin1))}(n,i,y,p,S,c)},decrypt:function(t,o){if(o.length>e.maxPassLen)return console.warn("Password is too long."),!1;const i=Utilities.fileReader(new Uint8Array(t));if("AES"!==i.readBytesAsString(3)||i.getLength()<136)return console.warn("File is corrupted or not an AES Crypt \n(or jsAesCrypt) file."),!1;if(i.readByte()!==e.fileFormatVersion)return console.warn("jsAesCrypt is only compatible with version \n2 of the AES Crypt file format."),!1;for(i.readByte();;){let e=i.readBytes(2);if(e.length<2)return console.warn("File is corrupted."),!1;if(0==(e=+Utilities.arrToInt(e)))break;i.readBytes(e)}const s=i.readBytesAsString(16);if(16!==s.length)return console.warn("File is corrupted."),!1;const a=r(o,s),l=i.readBytesAsString(48);if(48!==l.length)return console.warn("File is corrupted."),!1;const c=i.readBytesAsString(32);if(32!==c.length)return console.warn("File is corrupted."),!1;const p=CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256,Utilities.encode_to_words(a));if(p.update(Utilities.encode_to_words(l)),c!==CryptoJS.enc.Latin1.stringify(p.finalize()))return console.warn("Wrong password (or file is corrupted)."),!1;const d=n(a,s),y=d.process(Utilities.encode_to_words(l)).toString(CryptoJS.enc.Latin1)+d.finalize().toString(CryptoJS.enc.Latin1),S=y.substr(0,e.AESBlockSize),g=y.substr(e.AESBlockSize,32),f=n(g,S),u=CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256,Utilities.encode_to_words(g));let C=new Uint8Array([]);for(;i.getCurrentPosition()<i.getLength()-32-1-e.AESBlockSize;){let t=Utilities.encode_to_words(i.readBytes(Math.min(e.bufferSize,i.getLength()-i.getCurrentPosition()-32-1-e.AESBlockSize)),"Uint8Arr");u.update(t),C=C.appendBytes(f.process(t).toString(CryptoJS.enc.Latin1))}var A;if(i.getCurrentPosition()!==i.getLength()-32-1){if((A=i.readBytes(e.AESBlockSize)).length<e.AESBlockSize)return console.warn("File is corrupted."),!1}else A=new Uint8Array([]);A=Utilities.encode_to_words(A,"Uint8Arr"),u.update(A);const B=i.readBytesAsInt(1);let w=f.process(A).toString(CryptoJS.enc.Latin1)+f.finalize().toString(CryptoJS.enc.Latin1);const U=(16-B)%16;0!==U&&(w=w.substr(0,w.length-U)),C=C.appendBytes(w);const _=i.readBytesAsString(32);return 32!==_.length?(console.warn("File is corrupted."),!1):_!==CryptoJS.enc.Latin1.stringify(u.finalize())?(console.warn("Bad HMAC (file is corrupted)."),!1):C},createEncryptor:t,getInfo:function(){return e}}};const saveByteArray=function(e,t){const n=document.createElement("a");document.body.appendChild(n),n.style="display: none";const r=new Blob([e],{type:"octet/stream"}),o=window.URL.createObjectURL(r);n.href=o,n.download=t,n.click(),window.URL.revokeObjectURL(o),n.remove()};